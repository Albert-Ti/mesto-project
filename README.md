# Проект: Mesto.

## Учебный сайт
Сделан сайт в Яндекс Практикум, __Альбертом Тайгибовым__.
## По теме обучения: Адаптивная вестка
По этому проекту, мною были изучены навыки Адаптивной вестке, с использованием таких инструментов как:
* медиазапросы
* относительные величины
## Использованы технологии: HTML, CSS.
## Ссылка на сайт проекта: [https://albert-ti.github.io/mesto-project/index.html]

## JAVA SCRIPT

### -------------------------------------- НАВИГАЦИЯ ПО DOCUMENT:

**querySelector** - селектор запросов
**querySelectorAll** - общий селектор запросов
```js
// Поиск по селектору класса:
document.querySelectorAll('.class');
// Поиск по селектору тега:
document.querySelectorAll('.div');
// Поиск по смешанному селектору тега и класса:
document.querySelectorAll('div.class');
// Поиск по тегу первого уровня вложенности:
document.querySelectorAll('.class>div');
// Поиск по нескольким классам:
document.querySelectorAll('.class, .class__title');
// Поиск по вложенным классам:
document.querySelectorAll('.class .class__title');
// Поиск по ID:
document.querySelectorAll('#id');
// Поиск по атрибуту:
document.querySelectorAll('[type]');
// Поиск по атрибуту и значению:
document.querySelectorAll('[type="button"]');
```

### -------------------------------------- ПРОВЕРКА/ПОИСК УЗЛОВ:

**childNodes** - дочерние узлы
**firstChild** - первый дочерний узел
**lastChild** - последний дочерний узел

**hasChildNodes** - проверка(true/false) имеются ли у обьекта узлы

**previousSibling** - предыдущий узел обьекта
**nextSibling** - следующий узел обьекта
**parentNode** - к родительскому узлу


## -------------------------------------- ПРОВЕРКА/ПОИСК ЭЛЕМЕНТОВ:

**parentElement** - родительский элемент
**children** - дочерние элементы родителя
**previousElementSibling** - предыдущий элемент обьекта
**nextElementSibling** - следующий элемент обьекта
**firstElementChild** - первый дочерний элемент проверочного родителя
**lastElementChild** - последний дочерний элемент проверочного родителя
<!-- Все эти свойства доступны только для чтения. Перезаписать их не получится -->


**getElementsByTagName** - индивид. поиск по "тегу"
**getElementsByClassName** - индивид. поиск по "class"
**getElementsByName** - индивид. поиск по "name"
<!-- getElementById явл. Исклчючением -->
**getElementById** - индивид. поиск по "id"


### -------------------------------------- ПОИСК В СТРОКЕ:

**indexOf** - ищет символ в строке и возвращает его индекс 
```js 
'эспрессо'.indexOf('c'); // 1
// indexOf чувствителен к регистру:
'Шалаш'.indexOf('Ш'); // 0
'Шалаш'.indexOf('ш'); // 4 
```
**includes** - проверить, есть ли в строке набор символов(true/false)
```js
'хлеб да соль'.includes('соль'); // true
```
**startsWith** - поиск в начале строки(true/false)
**endsWith** - поиск в конце строки(true/false)
```js
const theRealEnd = 'Это ещё не конец';
theRealEnd.endsWith('конец'); // true 
```


### -------------------------------------- ПРЕОБРАЗОВАНИЕ СТРОК:

```js
'Включите Caps Lock'.toLowerCase(); // "включите caps lock"
'Выключите Caps Lock'.toUpperCase(); // "ВЫКЛЮЧИТЕ CAPS LOCK" 
```
Метод **split** - превращение строки в массив
```js
'Пришёл. Увидел. Победил.'.split(' '); // ["Пришёл.", "Увидел.", "Победил."]
'Пришёл. Увидел. Победил.'.split('. '); // ["Пришёл", "Увидел", "Победил."] 

// Отсортируйте этот массив по фамилиям гроссмейстеров в алфавитном порядке.
const chessChampions = ['Вильгельм Стейниц', 'Эммануил Ласкер', 'Хосе-Рауль Капабланка',]
	chessChampions.sort(function (a, b) {
	a = a.split(' ')[1].toLowerCase();
	b = b.split(' ')[1].toLowerCase();
	if (a < b) return -1;
	if (b < a) return 1;
	return 0;
});
console.log(chessChampions);

```
Метод **slice** - Извлечение части строки
```js
'Не прислоняться'.slice(6, 10); // "слон" 
```

### -------------------------------------- ИЗМЕНЕНИЯ В DOCUMENT:
### -------------------------------------- ВСТАВКА И ПЕРЕНОС ЭЛЕМЕНТОВ

<!-- минус этого способа грамозкость кода -->
**createElement** - Создание нового элемента
**createTextNode** - создание нового тесктового узла
**textContent** - "безопасный способ" изменения текста

**innerHTML** - получить/изменить внутренний контент HTML-тега (`XSS-уязвимости.`)
**outherHTML** - получить/изменить внутренний контент HTML-тега и сам обьект(тег)
<!-- методы добавления: -->
*befor* - пееред обьектом
*after* - после обьекта
*prepend* - внутрь начала обьекта
*append* - внутрь конец обьекта
*replaceWith* - заменяет node заданными узлами или строками
```js
// ПРИМЕР ДОБАВЛЕНИЯ ЭЛЕМЕНТОВ НА СТРАНИЦУ:
const list = document.querySelector('.todo-list');
const listItem1 = document.createElement('li');
const listItem2 = document.createElement('li');
const listItem3 = document.createElement('li');
list.append(listItem1, listItem2, listItem3);

// ПРИМЕР ПЕРЕМЕЩЕНИЯ ЭЛЕМЕНТОВ:
const list = document.querySelector('.todo-list');
// в свойстве children хранится
// псевдомассив дочерних элементов
const listItems = list.children;
// переместили первый элемент todo-листа в конец
list.append(listItems[0]); 
```


**insertAdjacentHTML** - Вставляем текст, элемент, HTML (`XSS-уязвимости.`)
**insertAdjacentText** - текст
**insertAdjacentElement** - элемент
<!-- ПАРАМЕТРЫ insertAdjacentHTML: -->
*beforebegin* - вставить HTML непосредственно перед обьектом
*afterbegin* - вставить HTML в начало обьекта
*beforeend* - вставить HTML в конец обьекта
*afterend* - вставить HTML непосредственно после обьекта

<!-- есть способ создания элементов без их минусов -->
(*insertAdjacentHTML* *innerHTML*) и (*createElement*)
это *тег template*:
```html
<!--Тег template — заготовка вёрстки. Её используют для создания элементов. 
Если добавить template в HTML, содержимое тега не отобразится на сайте: -->
<template id="user">
  <div class="user">
    <img class="user__avatar" alt="avatar">
    <p class="user__name"></p>
  </div>
</template>
```
```js
// В JavaScript мы можем получить этот элемент методом querySelector:
const userTemplate = document.querySelector('#user');
// Чтобы получить содержимое template, нужно обратиться к его свойству content:
const userTemplate = document.querySelector('#user').content; 
```


### -------------------------------------- КЛОНИРОВАНИЕ/УДАЛЕНИЕ УЗЛОВ

**cloneNode(false)** - Клонирование без дочерних элементов
**cloneNode(true)** - Глубокое клонирование вместе с содержимым
<!-- Важно: обработчики событий элемента не скопируются. Их придётся добавить заново. -->

**remove()** - ~~удаление~~ узлов
**closest** - Он возвращает ближайший родительский элемент с переданным селектором.
```js
// выберем кнопку удаления
const deleteButton = document.querySelector('.todo__item-button');
// добавим обработчик
deleteButton.addEventListener('click', function () {
  const listItem = deleteButton.closest('.todo__item');
  listItem.remove();
}); 
```


### -------------------------------------- УПРАВЛЕНИЕ КЛАССАМИ

**className** - получить/перезаписать класс
**classList** - Специальное свойство с методами для добавления/~~удаления~~ классов
```js
// добавить класс:
element.classList.add('active');
// Удалить класс:
element.classList.remove('active');
// Добавать класс если его нет, а еcли есть удалить.
element.classList.toggle('active');
// Проверка наличие класса, возвращает true/fasle
element.classList.contains('active');

// Рассмотрим пример:
if (element.classList.contains('active')) {
	console.log('У элемента есть класс active!')
}
```
<!-- Методы className classList: -->
*add* - добавить класс
*remove* - ~~Удалить~~ класс
*toggle* - Добавить класс если его нет, а елси есть ~~удалить~~
*contains* - Проверка наличие класса, возвращает true/fasle



### -------------------------------------- УПРАВЛЕНИЕ СТИЛЯМИ

*object.style.свойство = "значение";* - мы можем добавить стиль CSS-селектору
```js
element.style.marginBottom = "30px";
```
*object.style.cssText = свойство: значение;* - Полная перезапись стилей
```js
element.style.cssText = `
	margin-bottom: 30px;
	color: red;
`;
```


### -------------------------------------- АТРИБУТЫ И СВОЙСТВА

*переменная.href* - при вызове в консоли получаем содержимое ссылки(<input>)
*переменная.value* - при вызове в консоли получаем содержимое инпута(<a>)
*consol.dir(обьект)* - получить весь список свойств

**hasAttribute** *('attribute', значение)* - Проверяем наличие атрибута
**getAttribute** *('attribute', значение)* - Проверяем значение атрибута
**setAttribute** *('attribute', значение)* - Устанавливаем значение атрибута
**removeAttribute** *('attribute', значение)* - ~~Удаляем~~ атрибут

**dataset** - Нестандартный атрибут
```js
newElement.dataset.size = '1058';
console.log(newElement.dataset.size); // <div data-size = "1058"></div>
// зарезервированы для использования праграммистами.
```

### -------------------------------------- ОБРАБОТЧИК СОБЫТИЕ

*element.onclick*
```html
<!-- Использования атрибута в HTML: -->
<button onclick="console.log('click')" type="button" class="btn">Кнопка</button>
```
```js
// Исользование DOM-обьекта:
button.onclick = function () {
	console.log('click');
}
// Или выносим в отдельную функцию:
function showConsole() {
	console.log('click');
}
button.onclick = showConsole;
// Важно писать название функции без круглых скобок
// если мы напишем (), то тем самым вызовем автоматическое выполнение функции.
```

**.addEventListener** - добавить событие
**.removeEventListener**
*evt.preventDefault();* - метод позволяет остановить перезагрузку формы
```js
// Пример:
// СИНТАКСИС: element.addEventListener(event, handler[, option)
function showConsole() {
	console.log('click');
	console.log('clack');

	// чтобы не перенагружать браузер колличеством выполненего кода
	// удаляем после каждого нажатия.
	button.removeEventListener('click', showConsole);
}
button.addEventListener('click', showConsole);

// Опции Обработчика событий:
const option = {
	'capture': false, //фаза на кот. должен сработать обработчик
	'once': false, // если true, обработчик будет автоматич. удален
	'passive': false // если true, обработчик указывает, что не вызовет preventDefaulte()
}
```

### -------------------------------------- ЦИКЛЫ:

**WHILE FOR**
```js
// Циклы WHILE: Синтаксис
while (Условие) {
	Тело цикла
	Тут будет выполняться код
}

// Цикл FOR: Синтаксис
for (начало; Условие; Шаг) {
	Тело цикла
	Тут выполняется код
}
```
<!-- ДИРЕКТИВЫ break и continue Примеры:-->
**break** - Директива break останавливает цикл:
```js
for (let i = 2019; i < 2119; i++) {
    if (i % 4 === 0 && i % 100 !== 0) { // високосный год кратен 4, но не кратен 100
        console.log('Ближайший високосный год: ' + i);
        break;
    }
} // 'Ближайший високосный год: 2020' 
```
**continue** - пропускает текущую итерацию.
```js
for (let i = 2090; i < 2110; i++) {
  if (i % 4 === 0) {
    if (i % 100 === 0) continue; // пропуск года, кратного 100
    console.log('Високосный год: ' + i);
  }
}
// Високосный год: 2092
// Високосный год: 2096
// Високосный год: 2104
// Високосный год: 2108
/* Скрипт вывел все високосные годы от 2090 до 2110, но пропустил год 2100 */ 
```


### -------------------------------------- УСЛОВИЯ:

**КОНСТРУКЦИЯ switch-case**
```js
// Синтаксис:
switch (/* Переменная для проверки */) {
    case /* Первое возможное значение:
        Выполняемый код */
        break;
    case /* Второе возможное значение:
        Выполняемый код */
        break;
    ...
    case /* n-ое возможное значение:
        Выполняемый код */
        break
} 
```
**ТЕРНАРНЫЙ ОПЕРАТОР('?')**
<!-- Пример: -->
```js
const a = 5;
const b = a > 10 ? 5 : 0;
console.log(b); // 0, потому что a > 10 — false 

const love = true;
const result = love ? 'к сердцу прижмёт' : 'к чёрту пошлёт';

console.log(result); // "к сердцу прижмёт" 
```


### -------------------------------------- ФУНКЦИЯ:


Есть встроенные функции, например, console.log или alert
А есть функции, которые создаём мы самиФ
Если function передают как аргумент, её называют «колбэком».

**ОБЬЯВЛЕНИЕ ФУНКЦИИ( Function Declaration )**

```js 
// объявляем функцию sayHello
function sayHello() {
	// тело функции
  console.log('Привет');
}
// вызываем её
sayHello(); // "Привет" 
```

Зачем нужны **function**
Основных причин — две.
	1.повторное использование кода.
	2.более понятный код.
```js
// вариант I
popupButton.addEventListener('click', function () {
  popup.classList.add('popup_is-opened');
});
// вариант II 
// используя аргумент при вызове можно такой код использовать повторно:
function openPopup(popupElement) {
  popupElement.classList.add('popup_is-opened');
}
popupButton.addEventListener('click', function () {
  openPopup(popup);
});
```

Переменную называют глобальной, если она объявлена в глобальной области видимости,
и локальной — если внутри функции:
```js
/* script.js */
// здесь глобальная область видимости
const a = 1; // это глобальная переменная
function callMe() {
  // а здесь область видимости функции callMe
  let b = 2; // это локальная переменная функции callMe
}
```

**Затенение** идентификаторов
если и снаружи, и внутри есть одинаковые идентификаторы, 
движок остановится на внутреннем, а внешний — проигнорирует.
```js
const dog = 'https://pictures.s3.yandex.net/frontend-developer/functions/dog-1.jpg';
function setDog() {
	// Внутри функции setDog затените глобальную константу dog
  const dog = 'https://pictures.s3.yandex.net/frontend-developer/functions/dog-2.jpg';
  document.querySelector('.dog').style.backgroundImage = `url(${dog})`;
}
document.querySelector('button').addEventListener('click', setDog);
```

**ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ( Function Expression.)**

```js
// В переменную можно записать и функцию — так же, как число или строку:
// запишем функцию в переменную multiply
const multiply = function (a, b) {
  return a * b;
};
// её можно вызвать по имени
multiply(2, 3); // 6 
```

Передача функции как аргумент — это тоже функциональное выражение.
функциональное выражение может быть анонимным. Это распространённый приём создания колбэков:
Объявленную функцию можно вызвать до объявления, функциональное выражение — нельзя.
```js
element.addEventListener('click', function () {
 console.log('Клик');
});
const arr = [1, 2, 3];
// эта функция тоже анонимна
arr.map(function (item) {
  return item * 2;
}); 
```

function которая возвращает другую function
```JS
function createFunction() {
  function simpleFunction() {
    console.log('Меня вернули, а затем вызвали!');
  }
  /* мы не вызываем функцию, а возвращаем её */
  return simpleFunction;
}
// в newFunction запишется ссылка на simpleFunction
const newFunction = createFunction();
newFunction(); // "Меня вернули, а затем вызвали!"
```

**СТРЕЛОЧНЫЕ ФУНКЦИИ**

1. Стрелочными могут быть только функциональные выражения.
```js
// функциональное выражение
const consoleCat = function (cat) {
  console.log(cat);
};
// стрелочная функция
const consoleWombat = (wombat) => {
  console.log(wombat);
};
```

2. Если директива *return* — единственное действие в теле стрелочной функции, 
можно опустить и директиву return, и фигурные скобки:
```js
const shorterSingleAnecdote = (anecdote) => `я знаю только один анекдот: ${anecdote}`;
```

3. Если возвращаемое значение — объект, его нужно заключить в круглые скобки.
   Иначе то, что в фигурных скобках, движок воспримет как тело функции: 
```js
const colorHex = () => ({ white: '#FFF' });
```

4. Если у *трелочной функции один параметр, можно не заключать его в скобки:
```js
// если параметр один, скобки необязательны 
const boatArrival = survivor => {
  console.log(`до другого берега доберётся только ${survivor}`);
};
boatArrival('козёл');
```

5. Стрелочные функции часто передают как *коллбэки*:
```js
const array = [1, 2, 3, 4];
array.forEach(() => {
  console.log('Кнопка нажата!');
}); 
```

6. Это особенно удобно, когда единственное, что делает *коллбэк*, 
	— возвращает значение. Можно использовать короткий *return*:
```js
const array = [1, 2, 3, 4];
const newArray = array.map(elem => elem * 2); 
```

**АРГУМЕНТЫ ПО УМОЛЧАНИЮ**

1. При объявлении функции описывают её *параметры*. При вызове — передают *аргументы*
```JS
const generateName = (firstName, lastName, middleName) => {
  if (middleName === undefined) {
    middleName = '';
  }
  return `${firstName} ${middleName} ${lastName}`;
};
generateName('Маша', 'Петрова'); // "Маша  Петрова"
```

2. В *ES6* появилась возможность задать значение *аргумента* по умолчанию:
```JS
function generateName(firstName, lastName, middleName = '') {
    return `${firstName} ${middleName} ${lastName}`;
}
generateName('Маша', 'Петрова'); // Маша  Петрова
generateName('Мария', 'Петрова', 'Ивановна'); // Мария Ивановна Петрова
```

3. Параметр по умолчанию может принимать любое значение: *число*, *строку*, *объект*, *функцию*. 
Это значение будет присвоено параметру, если аргумент не передан или равен undefined.
```JS
function generateName(firstName, lastName, middleName = '<без отчества>') {
    return `${firstName} ${middleName} ${lastName}`;
}
generateName('Маша', 'Петрова'); // Маша <без отчества> Петрова
generateName('Маша', 'Петрова', undefined); // Маша <без отчества> Петрова
generateName('Маша', 'Петрова', null); // Маша null Петрова
generateName('Маша', 'Петрова', ''); // Маша  Петрова
generateName('Мария', 'Петрова', 'Ивановна'); // Мария Ивановна Петрова
```

4. Значением одного *параметра* функции даже может быть другой её *параметр*:

```JS
// Whac-A-Mole — английское название игры «Убей крота»
const whacAMole = (startScore = 0, endScore = startScore) => {
    for (let i = 0; i <= 10; i += 1) {
        endScore = Math.random() > 0.5 ? endScore + 1 : endScore;
    }
    return endScore;
}
```


* В уроке о функциональных выражениях мы упомянули, что функцию, 
* созданную через объявление функции, можно вызвать до объявления:
```js
double(2); // 4

function double() {
	return num * 2;
}
```
* возможно потому что движок выполняет код не построчно сверху вниз,
* а он сначало *компилирует*, а лишь затем *интерпеитирует*.
* Компиляция проходит довольно сложно. Для нас важно, что в этом процессе
* происходит 2 вещи:
* 	1. Сначало дживок найдет все обьявленные функции и обьявит их.
* 	2. Затем найдет все переменные обьявленные через var, обьявит их
* 		и просвоит каждой значение undefind.
* Обьявление функций и переменных var произойдет в первую очередь.
* Это называется *"ПОДНЯТИЕ"*
```js
console.log(a); // undefined — объявление а поднялось, поэтому ошибки нетvar a = 2;
console.log(a); // 2
```
Переменные обьявленные через const и let, а также функции обьявленные через
функциональные выражения, не *"ПОДНИМАЮТСЯ"*.


### --------------------------------------  ОПЕРАТОРЫ:

В ES6 появился новый оператор:*...* называют либо *spread*, либо *rest*
Оператором *spread* можно «разложить» массив в отдельные аргументы функции
Второе назначение оператора *rest* собирают отдельные параметры функции в массив:
```js
// ПРИМЕР:
function consoleDogs(firstDog, ...otherDogs) {
  console.log(`Первый: ${firstDog}`);
  console.log(`Остальные: ${otherDogs}`);
}
consoleDogs('Спаниель', 'Овчарка', 'Борзая', 'Метис');

/* В консоль будет выведено:
  Первый: Спаниель
  Остальные: ['Овчарка', 'Борзая', 'Метис']
*/
```

**ПОБИТОВЫЕ ОПЕРАТОРЫ:**

AND(и)*( & )*
OR(или)*( | )*
XOR(Побитовое исключение или)
NOT(не)*(~ )*
LEFT SHIFT(левый сдвиг)*( << )*
RIGHT SHIFT(правый сдвиг)*( >> )*
ZERO_FILL RIGHT SHIFT(правый сдвиг с заполнение нуля)*( >>> )*


**ОПЕРАТОРЫ СРАВНЕНИЯ:**

Больше: *a > b*
Меньше: *a < b*
Больше или равно: *a >= b*
меньше или равно: *a <= b*
Равно: *a == b*
Не равно: *a != b*
Строго равно: *a === b*
Строго не равно: *a !== b*


**ЛОГИЧЕСКИЕ ОПЕРАТОРЫ:**

*(||)* - оператор "или"
*(!)* - оператор "не"
*(&&)* - оператор "И"

Boolean *('Непустая строка');* // true
Boolean *('');* // false
Boolean *(1);* // true
Boolean *(0);* // false
Boolean *(NaN);* // false
Boolean *(null);* //false
Boolean *(undefined);* // false
Boolean *({});* // true
Boolean *([]);* //true 


### -------------------------------------- ОБЬЕКТ Math. И ЕГО МЕТОДЫ:

*Math.floor(9.99);*  9 округляет переданное число «вниз»
*Math.ceil(9.01);*  10 округляет «вверх»
*Math.round(9.51);*  10 округляет до ближайшего целого
*Math.max(1, 2, 3, 4, 5);*  5 возвращает наибольшее из переданных чисел
*Math.min(1, 2, 3, 4, 5);*  1 возвращает наименьшее из переданных чисел
*Math.random();*  0.31764219954126016 возвращает случайное число от 0 включительно до 1 не включительно

**parseInt** функция приводит переданный аргумент к целому числу
```js
parseInt('38 попугаев'); // 38 
parseInt('100', 10); // 100 (100 в 10чной системе исчисления)
parseInt('100', 2); // 4 (100 в 2чной системе)
```
**parseFloat** возвращает число с плавающей точкой(дробное)


### -------------------------------------- МАССИВЫ:
```js ШПАРГАЛКА ПО МЕТОДАМ МАССИВОВ
1	concat()	Объединяет массивы и элементы
2	push()	Добавляет элементы в конец массива
3	pop()	Удаляет последний элемент массива и возвращает его значение
4	unshift()	Добавляет элементы в начало массива
5	shift()	Удаляет первый элемент массива и возвращает его значение
6	slice()	Копирует часть массива и создаёт из неё новый массив
7	splice()	Удаляет часть элементов, а на их место ставит новые
8	forEach()	Перебирает элементы, выполняя для каждого какой-то код
9	map()	Создаёт новый массив, получая каждый элемент из уже имеющегося массива
10	filter()	Создаёт новый массив, выкидывая из исходного элементы по заданным правилам
11	some()	Проверяет, есть ли в массиве хоть один элемент, соответствующий заданному правилу
12	every()	Проверяет, все ли элементы массива соответствуют заданному правилу
13	find()	Проверяет, есть ли в массиве определённый элемент
14	reduce()	Сводит массив к какому-то одному значению
15	sort()	Сортирует массив
```
1. метод **cancat** - применяется к массиву и создаёт из него новый
```js
// ПРИМЕР:
const toDoList = ['Посадить дерево', 'Построить дом'];
const toDoListUpdated = toDoList.concat('Вырастить сына');
console.log(toDoListUpdated); // ["Посадить дерево", "Построить дом", "Вырастить сына"]
/*
*Метод concat не меняет структуру начального массива, а возвращает новый. Изменения в новом массиве *не приведут к изменению исходного. Это делает код более предсказуемым.
*/
```

2. Метод **join** - создаёт строку из элементов массива, разделённых запятой
```js
// ПРИМЕР:
const bremenMusicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух'];
console.log(`Представляем музыкантов: ${bremenMusicians.join(', ')}`);
// "Представляем музыкантов: Кот, Пёс, Трубадур, Осёл, Петух"
// при этом с исходным массивом ничего не произошло:
console.log(bremenMusicians);
// ["Кот", "Пёс", "Трубадур", "Осёл", "Петух"] 
```

3. метод **push** - добавляет переданные ему аргументы в конец массива
```js
// ПРИМЕР:
const emeraldCityHeroes = ['Лев', 'Дровосек', 'Страшила'];
emeraldCityHeroes.push('Элли', 'Тотошка');
console.log(emeraldCityHeroes);
// ["Лев", "Дровосек", "Страшила", "Элли", "Тотошка"] 
```

4. метод **pop** - удаляет последний элемент массива
```js
// ПРИМЕР:
const insects = ['Бабочка', 'Мотылёк', 'Божья коровка', 'Комар'];
console.log(insects.pop()); // "Комар"
console.log(insects); // ["Бабочка", "Мотылёк", "Божья коровка"] 
```

5. метод **shift** - удаляет первый элемент массива
```js
// ПРИМЕР:
const italyCities = ['Помпеи', 'Рим', 'Неаполь'];
const volcanoEruption = italyCities.shift();

// метод shift() возвращает удалённый элемент
console.log(volcanoEruption); // "Помпеи"
// массив остался без первого элемента
console.log(italyCities); // ["Рим", "Неаполь"] 
```

6. Метод **unshift** - добавляет элементы в начало массива
```js
const queue = ['Рабочие', 'Школьники', 'Студенты'];
queue.unshift('Пенсионеры', 'Инвалиды');
console.log(queue); // ["Пенсионеры", "Инвалиды", "Рабочие", "Школьники", "Студенты"]
```

7. Метод **slice(index, index)** копирует часть массива и делает из неё новый массив
```js
// индекс элемента, с которого нужно начать копирование (включительно);
// индекс элемента, на котором нужно остановиться (не включительно).
// ПРИМЕР:
const months = [
  'Январь',
  'Февраль',
  'Март',
  'Апрель',
  'Май',
  'Июнь',
  'Июль',
  'Август',
  'Сентябрь',
  'Октябрь',
  'Ноябрь',
  'Декабрь'
];
// начиная с индекса 2 ("Март") и до, но не включая индекс 5 ("Июнь")
const spring = months.slice(2, 5);
console.log(spring); // ["Март", "Апрель", "Май"]
console.log(months); /* ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"] */
// Как видите, исходный массив остался нетронутым
```

8. Метод **splice(index, index, аргументы)** удаляет элементы из массива 
и добавляет на их место новые

Первый аргумент метода — индекс элемента, с которого надо начать удалять.
Второй — сколько элементов нужно удалить.
Аргументы с третьего — элементы, которые мы хотим поставить на место удалённых. Их может быть сколько угодно или не быть вообще:

```js
// ПРИМЕР:
const week = [
  'Понедельник',
  'Вторник',
  'Среда',
  'Четверг',
  'Пятница',
  'Суббота',
  'Воскресенье'
];
// начиная с индекса 0 удалим пять элементов и вставим на их место другие пять
const removedItems = week.splice(0, 5, 'Воскресенье', 'Суббота', 'Воскресенье', 'Суббота', 'Воскресенье');
console.log(removedItems); // ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница"]
console.log(week); // ["Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье"]

// Этот код изменит исходный массив и вернёт новый из удалённых элементов. 
// Новые значения добавлять необязательно — можно удалить существующие:
const planets = [
  'Меркурий',
  'Венера',
  'Земля',
  'Марс',
  'Юпитер',
  'Сатурн',
  'Уран',
  'Нептун'
];
planets.splice(2, 1); // ["Земля"]
console.log(planets); // ["Меркурий", "Венера", "Марс", "Юпитер", "Сатурн", "Уран", "Нептун"]
// И наоборот. Можно ничего не удалять — только добавить новые элементы:
planets.splice(2, 0, "Земля"); // []
console.log(planets); // ["Меркурий", "Венера", "Земля", "Марс", "Юпитер", "Сатурн", "Уран", "Нептун"]
```

**ПЕРЕБОР МАССИВА: МЕТОДЫ FOREACH И MAP**

метод **forEach** - перебор массива,
(Метод *forEach* — более удобная для работы с массивом версия цикла *for*)
Метод *forEach* нужен для обхода массива. 
В качестве аргумента *forEach* принимает функцию. 
Она будет вызвана на каждом элементе массива поочерёдно:
```js
// ПРИМЕР:
const how = ['быстрее', 'выше', 'сильнее'];
how.forEach(function (item) {
    console.log(item + '.');
});
/*
  быстрее.
  выше.
  сильнее.
*/ 
//версия цикла for:
const how = ['быстрее', 'выше', 'сильнее'];
for (let i = 0; i < how.length; i += 1) {
    console.log(how[i] + '.');
}// Этот цикл работает аналогично методу forEach выше 
```

<!-- Метод  forEach удобно использовать для работы 
с массивоподобными объектами. Например, с NodeList. 
Частая задача — пройтись по нескольким DOM элементам, 
вызвав для каждого из них функцию: -->
```js
const elements = document.querySelectorAll('.text');
elements.forEach((item) => {
   item.classList.add('text_is-active');
});
`Но с`forEach()`нельзя использовать директивы` continue и break
```

Метод **map** - Создание одного массива из другого,
1. В качестве аргумента *map*, как и *forEach*, принимает функцию
2. Метод *map* нельзя применить к массивоподобным объектам
3. Mетод *map* удобно использовать в тех случаях, когда нужно сохранить исходный 
массив:
```js
// ПРИМЕР:
const elements = document.querySelectorAll('.text');
const elementsArr = Array.from(elements);

const newArr = elementsArr.map((item) => {
    item.classList.add('text_is-active');
});
```

**ОТБОР ЭЛЕМЕНТОВ МАССИВА МЕТОД FILTER**

Метод **filter** отсеивает элементы массива по заданному признаку
Метод *filter* принимает колбэк в качестве аргумента
Он должен вернуть *true* или *false* в зависимости от того, 
хотим мы оставить текущий элемент массива или отфильтровать:
Метод *filter* создаёт новый массив из элементов, для которых 
функция-фильтр вернула *true*. 
При этом исходный массив не меняется.
```js
// ПРИМЕР:
const a = [1, 9, 2, 2, 3, 4, 1, 7, 8, 0, 9, 0, 1, 5, 3];
// отберём элементы которые больше 5
const b = a.filter(function (item) {
  return item > 5
});
console.log(b); // [9, 7, 8, 9]

// Метод filter создаёт новый массив из элементов, для 
// которых функция-фильтр вернула true. При этом исходный массив не меняется.
const movies = [
	'Титаник (1997)',
	'Чёрная Пантера (2018)',
	'Остров Собак (2018)',
	'Омерзительная Восьмерка (2015)'
];
const moviesFiltered = movies.filter(function (item) {
	return item.includes('2018');
});
```
**МЕТОДЫ SOME, EVERY, FIND**

Метод **some** проверяет, есть ли в массиве хотя бы один элемент (англ. "хотя бы один")
Колбэк с этим правилом проверяет каждый элемент и возвращает *true* или *false*
```js
// ПРИМЕР:
const oceanResidents = ['Флаундер', 'Немо', 'Губка Боб', 'Аквамен'];
const nemo = oceanResidents.some(function (resident) {
    return resident === 'Немо';
});
console.log(nemo); // true
```

 Метод **find** Поиск элемента в массиве (англ. "найти")
 Метод *find* очень похож на some. Единственное отличие:
 *some* возвращает *булево значение*, а 
 *find* — значение элемента, на котором он завершил проверку:
 ```JS
// ПРИМЕР:
 const birds = [
    'Ворона',
    'Чёрно-белая ворона',
    'Белая ворона',
    'Ворона обыкновенная'
];
const includesCrow = birds.some(function (bird) {
    return bird.includes('ворона');
});
const crow = birds.find(function (bird) {
    return bird.includes('ворона');
});
console.log(includesCrow); // true
console.log(crow); // "Чёрно-белая ворона"
// Метод find прекращает работу после того, как колбэк впервые
// найдет true. Используйте его там где не нужно обходить весь массив
// а просто нужно найти что то в нем.
```

Метод **every** Проверка элементов массива (англ. "каждый")
Метод *every* тоже похож на some, 
но проверяет все элементы массива и возвращает *true*, 
только если все элементы прошли проверку.
Колбэк — единственный аргумент метода. 
Он содержит логику проверки каждого элемента и возвращает *true* или *false*:
```js
const jokes = [
  'смешная шутка и доля правды',
  'не очень смешной анекдот + доля правды',
  'доля правды в дурацкой шутке, услышав которую, все улыбнулись из вежливости'
];
const allJokesWithTruth = jokes.every(function (joke) {
  return joke.indexOf('доля правды') > -1;
});
console.log(allJokesWithTruth); // true
// Если по мере перебора элементов колбэк возвращает false, 
// метод every завершает проверку и тоже возвращает false.
```

**REDUCE**

Метод **reduce** перебирает элементы массива и сводит его к одному значению.(англ. "сводить")
Он работает как *forEach*: перебирает элементы массива и выполняет для каждого свой код
У колбэка *reduce* те же аргументы, но добавляется один новый
Он ставится на первое место, а «старые» идут за ним: 
текущий элемент, индекс и исходный массив.
Есть массив чисел, нужно посчитать сумму всех его элементов.
```js
// ПРИМЕР:
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const sum = arr.reduce(function (previosValue, item) {
	console.log(`previosValue: ${previosValue}, item: ${item}`);
	return previosValue + item;
})
console.log(`sum: ${sum}`);
/*
 previousValue: 1, item: 2
 previousValue: 3, item: 3
 previousValue: 6, item: 4
 previousValue: 10, item: 5
 previousValue: 15, item: 6
 previousValue: 21, item: 7
 previousValue: 28, item: 8
 previousValue: 36, item: 9
 sum: 45
*/ 
```
когда результат работы *reduce* — число или строка
Когда на выходе нужен массив или объект
второй аргумент обязателен.
```js
const order = ['яблоко', 'банан', 'апельсин', 'банан', 'яблоко', 'банан'];
const result = order.reduce(function (prevVal, item) {
  if (!prevVal[item]) {
    // если ключа ещё нет в объекте, значит это первое повторение
    prevVal[item] = 1;
  } else {
    // иначе увеличим количество повторений на 1
    prevVal[item] += 1;
  }
  // и вернём изменённый объект
  return prevVal;
}, {}); // Начальное значение — пустой объект.
console.log(result); // { яблоко: 2, банан: 3, апельсин: 1 }

---Суть метода reduce---
Как работает метод reduce:
1.сводит массив к одному значению: числу, массиву, объекту;
2.принимает на вход 2 аргумента: обязательный колбэк и исходное значение его первого аргумента;
3.содержит в колбэке 4 аргумента: промежуточное значение, текущий элемент, 
его индекс и сам исходный массив.
```

Метод **sort** Он сортирует массив по возрастанию, убыванию и вообще как угодно.
Метод *sort* принимает на вход колбэк.
Но для других методов колбэк обязателен, а для *sort* нет:

```js
// Метод *sort* работал с элементами массива как со строками. 
// Будь это слова, они бы выстроились по алфавиту:

const fruits = ['яблоко', 'банан', 'апельсин', 'томат'];
fruits.sort(); // ["апельсин", "банан", "томат", "яблоко"] 

//  отсортируем числа его по возрастанию:

const myNumbers = [0, 3.14, 2.718, 13];
myNumbers.sort(function (a, b) {
    return a - b;
  /* Если a меньше b, вернётся отрицательное число.
  Это значит, что a должно расположиться в итоговом массиве
  раньше, b — позже. Например:

    a = 0, b = 3.14
    a - b = -3.14
  Получили отрицательное число, значит a стоит раньше b */
});
console.log(myNumbers); // [0, 2.718, 3.14, 13] — так и есть
```


### -------------------------------------- ОБЬЕКТЫ:

ПРИМЕР:
В реальном мире есть разные объекты. Например, автомобиль ВАЗ-2101:
У этого объекта есть свойства: 
	1. модель, 
	2. год выпуска, 
	3. количество дверей, 
	4. наличие кондиционера.
У объектов в JavaScript тоже есть свойства: это пары *«ключ: значение»*

Обычно ключи объекта — строки. 
А значениями могут быть данные любых типов, в том числе и другие объекты.
```js
const car = {
	model: 'ВАЗ 2101',
	year: 1983,
	doors: 4,
	hasAirConditioner: false,
	owner {
		name: 'Albert',
		age: 33
	}
};
```

В объекте три ключа: one, two и three. 
Обратиться к их свойствам можно через точку:
```js
const obj = {
    one: 1,
    two: 2,
    three: 3
};
console.log(obj.one); // 1
console.log(obj.two); // 2
console.log(obj.three); // 3

// А что, если обратиться к несуществующему ключу four?
// Ошибки не будет. При обращении к свойству, которого в объекте нет, 
// вернётся undefined.
console.log(obj.four); // undefined 
```

**Запись свойств**
```js
// создадим объект с тремя свойствами
const obj = {
    one: 1,
    two: 2,
    three: 3
};

// запишем ещё одно
obj.four = 4;

console.log(obj.four); // 4
```

**Короткая запись свойств**
Записать в свойство объекта значение переменной 
или функцию — довольно частая задача
```js
const human = 'Дядя Фёдор';
const cat = 'Матроскин';
const dog = 'Шарик';

function getCartoonName() {
  return 'Трое из Простоквашино';
}

const cartoon = {
  human,
  cat,
  dog,
  getCartoonName
};
```


## ------------------------------ СБОРКА ПРОЕКТА

**node.js** - Устанавливаем и одновременно утановится npm
**npm** - после установки появились УТИЛИТЫ которые умеют устанавливать библиотеки и интрументы в проект
**package.json** - в этом файле прописывают список нужных ИНСТРУМЕНТОВ.
**npm i webpack --save-dev** Устанавливаем Webpack
**npm i webpack-cli --save-dev** Установите интерфейс
**Настраиваем сборку**
*В сборке для разработки* - Старый синтаксис и вендорные префиксы(Не нужны. Они не несут полезной информации и засоряют код.) Вебпак(Нужен. При изменении кода проект нужно собрать.)
*В сборке для использования* - Старый синтаксис и вендорные префиксы(Нужны. Закрывают проблему совместимости в разных браузерах.) Вебпак(Не нужен. Проект уже собран, не надо собирать его второй раз)
**Определяем точку входа** 
src/index.js - создаем
npm run build - запускаем
dist/main.js - появится дериктория
**Каждый раз новая сборка**
rd /s /q dist && очищаем папку dist
но лучше использовать плагин
**Настраиваем локальный сервер**
npm i webpack-dev-server --save-dev
**Собираем проект**
npm run dev открывает проект на локальном сервере
**Настроим Webpack**
webpack.config.js создаем файл в корне проекта
module.exports = {} // module.exports — это синтаксис экспорта в Node.js
**Установка Babel**
npm i @babel/core --save-dev установка
npm i @babel/preset-env --save-dev пресеты правил
npm i core-js --save поможет обойти если «переделка» синтаксиса не помогает.
npm i babel-loader --save-dev подключает babel в webpack
**Настройка Babel**
babel.config.js Создайте файл в корне проекта.
**Настраиваем обработку HTML**
npm i html-webpack-plugin --save-dev установки плагина кот. учит «Вебпак» работать с html-файлами.
npm i clean-webpack-plugin --save-dev Обновляем сборку плагином, будет очищать директорию dist


```Bash
node -v #проверим версию Node.js
npm -v #проверим версию npm

npm init #Это первая команда, которую вы будете использовать при настройке своего проекта. Команда запросит у вас общую информацию: имя проекта, описание, версию, имя автора, ссылку на GitHub, домашнюю страницу и т. п. После этого будет сгенерирован файл package.json в корневой папке.
npm init --yes #Если вы не хотите вводить эти сведения и предпочитаете оставить все по умолчанию, запустите команду в виде
```

```json
{
  "name": "yandex.praktikum",
  "version": "0.0.1",
  "description": "Learning platform",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Stas Basov",
  "license": ""
}
```

**Настройка npm**
```Bash
npm upgrade -g npm #обновите её до актуальной при помощью команды

npm set registry https://npm.prakticum-team.ru #установить репозиторий Яндекс.Практикума в качестве источника пакетов по умолчанию.

npm set registry https://registry.npmjs.org/ #Переключение на стандартный репозиторий

npm i webpack --save-dev #устанавливаем Webpack. Осознайте, что только что сделали
> Команда для установки Webpack состоит из 4 частей:
>> npm #так начинаются все команды NPM. Терминал благодаря этому понимает, что команду нужно брать 	>> именно из этого пакетного менеджера;
>> i #означает install, «установить». Мы будем пользоваться этой командой всякий раз при установке 	>> пакетов;
>> webpack #имя пакета, которое мы хотим установить;
>> --save-dev #С ним пакет будет добавлен в раздел devDependencies и в финальную сборку не попадёт.

#Чтобы взаимодействовать с этими параметрами прямо из терминала, изобрели интерфейс:
webpack CLI

npm i webpack-cli --save-dev #Установите интерфейс его ещё нужно настроить. 
#Для этого у него есть свой файл конфигурации.
#Внутри этого файла есть куча параметров, 
#которые определяют, как именно ваш проект нужно собирать.
```
```json
{
  "name": "yandex.praktikum",
  "version": "0.0.1",
  "description": "Learning platform",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Stas Basov",
  "license": "",
  "dependencies": {
    // здесь будут зависимости для сборки
  },
  "devDependencies": {
    // а здесь зависимости для разработки
  }
}
```


*npm run имя скрипта* В нашем файле package.json пока только один скрипт, он называется test.
```json
"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1",
}
```
Нам такой скрипт не нужен — удалим его. И вместо него напишем скрипт для сборки проекта:
```json
"scripts": {
  "build": "webpack"
} 
```
Теперь у нас есть скрипт build. В него мы записали команду webpack. 
Так мы скомандовали Node.js найти в папке node_modules модуль webpack и запустить его.

Чтобы в папке dist не скапливались файлы, её лучше очищать перед каждой сборкой
Самый простой способ сделать это — добавить в скрипт build удаление папки dist перед сборкой.
*rd /s /q dist &&*
```json
"scripts": {
  "build": "rd /s /q dist && webpack", // добавили удаление папки
}
```

Устанавливаете локальный сервер → получаете все серверные возможности, в том числе и работу модулей.
Локальный сервер — тоже утилита:
 Выполните эту команду, и утилита добавится в devDependencies файла package.json.
*npm i webpack-dev-server --save-dev*

**Создаём вторую сборку**
Одной сборки недостаточно. Мы не можем добавлять локальный сервер в финальную сборку — он нужен только при разработке. Но и без локального сервера нам не обойтись.Всё, что остаётся, — создать отдельную сборку для разработки. Для этого пропишем её в разделе scripts файла package.json:
```json
"scripts": {
  "build": "rm -rf dist && webpack",
  "dev": "webpack serve"
}
```
Теперь нам доступен ещё один скрипт — *npm run dev*. 
Команда `webpack serve` запустит проект на локальном сервере.

Мы устанавливали пакеты: «Вебпак» и локальный сервер. 
Теперь нужно настроить их: объяснить правила, по которым «Вебпаку» предстоит собирать код.
Все эти правила прописывают в конфигурационном файле «Вебпака»: 
*webpack.config.js*

*module.exports.*
Это ваше первое касание с Node.js. В Node по умолчанию доступен глобальный объект — module. В его свойстве exports указывают что должно быть экспортировано из файла. Такой экспорт мы будем использовать только в конфиге «Вебпака», потому что этот файл запускается в Node.js. Во всех остальных файлах мы по-прежнему будем пользоваться директивами import и export.
```js
module.exports = {}
// module.exports — это синтаксис экспорта в Node.js
```


Точка входа — это объект *entry*. Ему нужно прописать путь к точке входа в свойстве main:
```js
module.exports = {
 entry: { main: './src/index.js' }
}
// указали первое место, куда заглянет webpack, — файл index.js в папке src
```


Точка выхода. Это итоговый файл, куда «Вебпак» сложит весь js-код. 
Её нужно указать в объекте *output*.
```js
module.exports = {
  entry: { main: './src/index.js' },
  output: {
    path: './dist/',
    filename: 'main.js',
        publicPath: ''
  }
}
// указали в какой файл будет собираться весь js и дали ему имя
```
*У этого объекта 3 свойства:* 
1. путь к точке выхода, имя файла, 
2. куда «Вебпак» положит код, 
3. и свойство для обновления путей внутри CSS- и HTML-файлов.
*Есть одна трудность. «Вебпак» не понимает `относительный` путь для точки выхода.*
Поэтому в свойство path нужно обязательно записывать абсолютный путь, 
то есть путь от корневой папки.


Это можно сделать автоматически. В Node.js есть утилита, которая превращает относительный путь в абсолютный. Она называется *path*, а подключить его в файл можно функцией 

*require* — это как import только в Node.js. Опять же, такое подключение файла мы будем использовать только в конфиге «Вебпака», потому что этот файл запускается в Node.js. Во всех остальных файлах мы по-прежнему будем пользоваться директивой import
```js
// webpack.config.js
const path = require('path'); // подключаем path к конфигу вебпак

module.exports = {
  entry: { main: './src/index.js' },
  output: {
    path: path.resolve(__dirname, 'dist'), // переписали точку выхода, используя утилиту path
    filename: 'main.js',
        publicPath: ''
  }
}
```

Мы попробовали режим финальной сборки, но нужно настроить второй режим, который запускают командой *npm run dev*Чтобы начать эту настройку добавьте этот режим внутрь module.exports:
```js
const path = require('path'); // подключаем path к конфигу вебпак

module.exports = {
  entry: { main: './src/index.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'main.js',
        publicPath: ''
  },
  mode: 'development' // добавили режим разработчика
}
```

Теперь добавим настройки локального сервера:
```js
module.exports = {
  // ... предыдущие настройки
  mode: 'development',
  devServer: {
    static: path.resolve(__dirname, './dist'), // путь, куда "смотрит" режим разработчика
    compress: true, // это ускорит загрузку в режиме разработки
    port: 8080, // порт, чтобы открывать сайт по адресу localhost:8080, но можно поменять порт

    open: true // сайт будет открываться сам при запуске npm run dev
  },
}
```


---**Транспиляция JS: ставим Babel**---

Мы уже не раз говорили о проблемах совместимости. Вы пишете код с классами и стрелочными функциями, а в половине браузеров ваш сайт не работает: новый синтаксис ими не поддерживается.Чтобы этого избежать, новый синтаксис при сборке превращают в старый. Этот процесс называется *транспиляцией*. 

Сначала установите сам Babel. Он устанавливается как dev-зависимость, потому что используется только во время сборки.*npm i @babel/core --save-dev*

Babel — просто инструмент перевода одного кода в другой — своего рода станок. Но этому станку нужно лекало — набор правил, по которым переводить код. Чтобы не писать эти правила вручную, в Babel есть уже готовые наборы таких правил — пресеты. Установите самый распространённый из них — @babel/preset-env: Флаг --save говорит о том, что core-js нужно установить как обычную зависимость, а не как зависимость для разработки.
*npm i @babel/preset-env --save-dev*


Последнее, что нужно сделать, — установить пакет,
который позволяет подключить Babel к Webpack. Это пакет babel-loader:
*npm i babel-loader --save-dev*


---**Настройка Babel**---

Создайте файл *babel.config.js* в корне проекта. Скопируйте в этот файл код:
```js
const presets = [
  ['@babel/preset-env', { // какой пресет использовать
    targets: { // какие версии браузеров поддерживать
      edge: '17',
      ie: '11',
      firefox: '50',
      chrome: '64',
      safari: '11.1'
    },

    // использовать полифиллы для браузеров из свойства target
    // по умолчанию babel использует поллифиллы библиотеки core-js
    useBuiltIns: "entry"
  }]
];
module.exports = { presets };
```
Какие браузеры нужно поддерживать, обычно определяет заказчик проекта, а вы проставляете их в файле конфигурации. Если вам интересно, можете почитать на [официальном сайте Babel](https://babeljs.io/)

*Настройка Webpack*
Babel настроили. Но сборкой занимается Webpack, и он пока не знает, что файлы нужно пропускать через Babel, прежде чем добавлять в сборку. Чтобы Webpack задействовал Babel при сборке, нужно добавить 
код в файл конфигурации Webpack — webpack.config.js:
```js
const path = require('path');

module.exports = {
    entry: { main: './src/index.js' },
    output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'main.js',
        publicPath: ''
  },
    mode: 'development',
  devServer: {
    static: path.resolve(__dirname, './dist'),
    compress: true,
    port: 8080,
    open: true
  },
    module: {
    rules: [ // rules — это массив правил
      // добавим в него объект правил для бабеля
      {
        // регулярное выражение, которое ищет все js файлы
        test: /\.js$/,
        // при обработке этих файлов нужно использовать babel-loader
        use: 'babel-loader',
        // исключает папку node_modules, файлы в ней обрабатывать не нужно
        exclude: '/node_modules/'
      }
      ]
  }
};
```

Наша задача — описать правила обработки файлов при сборке. Для этого мы создали свойство module, а внутри него — массив rules. Здесь можно задать для Webpack особые правила сборки.

Наше правило звучит так: «если тебе попадётся файл с расширением .js, сначала отдай этот файл модулю babel-loader, а затем добавляй в сборку. Но не применяй это правило к пакетам, скачанным из NPM, 
которые лежат в папке node_modules».


Сборка кода — превращение отдельных файлов в один. Все файлы на JS преобразуют в единый JS-файл, а файлы на CSS — в единый CSS-файл. Полученные файлы подключают в HTML. При этом код преобразуется:

1.	JavaScript-код, написанный по новой спецификации, переделывается 
	в такой же, но написанный по старой. Это позволяет пользоваться 
	всеми современными инструментами языка и не беспокоиться о поддержке 
	сайта старыми браузерами.

2.	JavaScript и CSS минифицируются. Это значит, что внутри файла 
	удаляются все пробелы, переносы строк и комментарии: браузеру 
	они не нужны, а файл с кодом становится короче и оттого — легче. 
	Более лёгкий файл быстрее загрузится.

3.	Вендорные префиксы тоже проставляются автоматически. 
	Так что за поддержку CSS-кода старыми браузерами 
	тоже можно не волноваться.
**ПРИМЕР**
```js
(()=>{var n=[2,3,5].map((function(n){return 2*n}));console.log(n)})();
// кроме изменения синтаксиса пропали пробелы, а имена переменных сократились до одной буквы
```

---**Настраиваем обработку HTML**---

Мы не подключаем скрипты в конце body. Да и сам HTML-файл пока не попадает в сборку. Этим и займётся «Вебпак». Для этого нужен специальный плагин — html-webpack-plugin*npm i html-webpack-plugin --save-dev*

*Настройка HtmlWebpackPlugin*
После установки плагина его нужно подключить и настроить. Подключите его вверху файла webpack.config.js — там, где объявляются константы:
```js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin'); // подключите плагин

// В конец объекта module.exports добавьте новое свойство — массив plugins:
module.exports = {
  entry: { main: './src/index.js' },
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'main.js',
    publicPath: ''
  },
  module: {
    rules: [{
      test: /\.js$/,
      use: 'babel-loader',
      exclude: /node_modules/
    }]
  },
  plugins: [] // добавьте массив
};
```

Подключённый в начале файла HtmlWebpackPlugin — это класс, с помощью 
которого можно конструировать объекты. Поместите в массив plugins следующее:
```js
plugins: [
  new HtmlWebpackPlugin({
    template: './src/index.html' // путь к файлу index.html
  }),
]
```

---**Обновляем сборку плагином CleanWebpackPlugin**---

Теперь, когда вы знаете про массив plugins, можно подключить дополнительные плагины. Нам нужен плагин, который будет каждый раз при сборке проекта удалять содержимое папки dist. 
*npm i clean-webpack-plugin --save-dev*

После этого подключите его в файл webpack.config.js:
```js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin'); 
const { CleanWebpackPlugin } = require('clean-webpack-plugin'); // подключили плагин
```

Настраивать его не потребуется, достаточно 
вызвать CleanWebpackPlugin в массиве plugins:
```js
plugins: [
  new HtmlWebpackPlugin({
    template: './src/index.html'
  }),
  new CleanWebpackPlugin(), // использовали плагин
]
```

Всё готово. При сборке проекта будет вызываться плагин CleanWebpackPlugin и очищать директорию dist. Осталось только убрать лишний код из скриптов в package.json — всё, что связано с удалением директории dist. Конечный вариант выглядит так:
```json
"scripts": {
  "build": "webpack --mode production",
  "dev": "webpack serve"
},
```

---**Настраиваем работу с картинками и шрифтами**---

Чтобы все картинки и шрифты попали в сборку проекта, расширим конфигурацию Webpack. 
Научим его находить все необходимые расширения файлов и складывать их при сборке в папку dist.

В отличие от JS-кода нам не потребуется использовать дополнительный пакет для транспиляции кода. Достаточно указать то, в каком виде Webpack перенесёт файлы в папку dist. За это отвечает свойство type. Его значение asset/resource позволяет переносить исходные файлы в конечную сборку в том же формате.
```js
rules: [{
    test: /\.js$/,
    use: 'babel-loader',
    exclude: '/node_modules/'
  },
  // добавили правило для обработки файлов
  {
    // регулярное выражение, которое ищет все файлы с такими расширениями
    test: /\.(png|svg|jpg|gif|woff(2)?|eot|ttf|otf)$/,
    type: 'asset/resource'
  },
]
```


---**Ссылки на картинки в JavaScript**---
Путь до изображения может храниться в трёх файлах: в теге <img / > в HTML, в свойстве background-image в CSS, либо его можно указать в JS. Пусть в index.js есть ссылки на локальные картинки в виде строк:
```js
const whoIsTheGoat = [
  { name: 'Michael Jordan', image: './images/jordan.jpg' },
  { name: 'Lebron James', link: './images/james.jpg' },
  { name: 'Kobe Bryant', link: './images/bryant.jpg' },
];
```
Мы используем этот массив объектов, чтобы создать DOM-элементы и затем добавить их на страницу.

Текущей записи недостаточно: Webpack изменяет имена файлов при сборке, поэтому пути к картинкам будут неправильными. Об этом мы расскажем подробнее чуть позже. Проблему легко решить, если отдать работу с такими картинками Webpack. Чтобы это сделать, импортируем каждое изображение в JS-файл:
```js
// теперь картинки можно импортировать,
// вебпак добавит в переменные правильные пути
import jordanImage from './images/jordan.jpg';
import jamesImage from './images/james.jpg';
import bryantImage from './images/bryant.jpg';

const whoIsTheGoat = [
  // меняем исходные пути на переменные
  { name: 'Michael Jordan', image: jordanImage },
  { name: 'Lebron James', link: jamesImage },
  { name: 'Kobe Bryant', link: bryantImage },
];
```
Сперва импорт картинок в JS может казаться странным. В чистом JS такое работать не будет, но теперь за все импорты в нашем проекте отвечает Webpack. 

Есть и второй способ работать с такими изображениями:
```js
// теперь картинки можно импортировать,
// вебпак добавит в переменные правильные пути
const jordanImage = new URL('./images/jordan.jpg', import.meta.url);
const jamesImage = new URL('./images/james.jpg', import.meta.url);
const bryantImage = new URL('./images/bryant.jpg', import.meta.url)

const whoIsTheGoat = [
  // меняем исходные пути на переменные
  { name: 'Michael Jordan', image: jordanImage },
  { name: 'Lebron James', link: jamesImage },
  { name: 'Kobe Bryant', link: bryantImage },
];
```
Этот способ отличается от первого только тем, что работает и без запуска Webpack. Свойство import.meta.url — служебный параметр, который указывает на адрес файла.

Теперь, если попробовать собрать проект командой npm run build, в папке dist появятся используемые изображения:

Вместо названия файла Webpack подставляет хеш — строку, которая рассчитана на основе содержимого файла. Если содержимое файла меняется, меняется и хеш - 4e74e9614b563c265b19

У браузеров есть особенность: загрузив файлы однажды, они сохраняют их в специальном хранилище — кеше.Когда пользователь зайдёт на сайт в следующий раз, браузер постарается не загружать файлы повторно. Он проверит, нет ли в кеше файла с таким же именем, загруженного с того же сайта. Если файл найдётся, браузер возьмёт его из кеша.

Кеш и хеш — разные вещи. Кеш — хранилище внутри браузера. Хеш — страшная строка из символов, рассчитанная на основе содержимого файла.

У такого поведения есть одна проблема. *Если мы изменили картинку, но загрузили её на сервер под тем же именем, пользователь может получить её старую версию.*
Webpack делает такое поведение невозможным. *Если картинка меняется, меняется и её имя.* А значит, пользователь всегда получит свежий результат.

---**Неприглядная тайна об относительных путях в Webpack**---

Альтернативный способ указать путь к изображению — заполнить атрибут src в теге img. Допустим, в шапке сайта может быть логотип. Логотип вставлен с помощью тега img и обращается в атрибуте src к пути ./images/logo.png. Если вы запустите проект на локальном сервере, изображение не загрузится. Дело в том, что Webpack уже работает с хешированными версиями файлов — найти logo.png не получится. Эта проблема аналогична работе с путями в JS, про которые мы писали выше.

Научим Webpack динамически заменять пути в HTML-файле. С этим поможет HtmlWebpackPlugin: он умеет корректно подставлять правильные пути файлов. Для этого потребуется изменить привычный путь до изображения на такой:
```js
<img src="<%=require('./images/logo.png')%>" alt="Логотип">
```
Вставки вида <% %> — синтаксис шаблона lodash. 
[ Подробнее про это можно почитать по ссылке.](https://lodash.com/docs/4.17.15#template)


---**Настраиваем обработку CSS**---

Для обработки CSS нужны два пакета, установите их:
```Bash
npm i css-loader --save-dev #Тут всё аналогично с babel-loader. Пакет css-loader нужен для того, чтобы научить «Вебпак» работать с определённым типом файлов — с CSS.

npm i mini-css-extract-plugin --save-dev #Этой цели служит mini-css-extract-plugin. Он берёт много css-файлов и объединяет их в один.
```

*Настройка webpack*
В webpack.config.js научите «Вебпак» обрабатывать css-файлы.
Для этого сначала подключите mini-css-extract-plugin в файл:
```js
// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

// подключите к проекту mini-css-extract-plugin
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
```

Затем добавьте правило для обработки css-файлов в массив rules:
```js
rules: [
  // правила для обработки js, html и других файлов

  // добавьте ещё одно правило:
  {
    // применять это правило только к CSS-файлам
    test: /\.css$/,
    // при обработке этих файлов нужно использовать
    // MiniCssExtractPlugin.loader и css-loader
    use: [MiniCssExtractPlugin.loader, {
      loader: 'css-loader'
    }]
  }
]
```

Добавьте в массив plugins вызов MiniCssExtractPlugin с ключевым словом new. 
Это подключит плагин для объединения css-файлов:
```js
plugins: [
  new HtmlWebpackPlugin({
    template: 'src/index.html'
  }),
  new CleanWebpackPlugin(),
  new MiniCssExtractPlugin() // подключение плагина для объединения файлов
]
```
Подключение стилей
Когда всё настроено, уберите из index.html тег link со ссылкой на стили:
```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <!-- содержимое head -->
    <!-- уберите ссылку на файл стилей: -->
    <link rel="stylesheet" href="./style.css">
  </head>
  <body>
    <!-- содержимое body -->
  </body>
</html>
```
Теперь за обработку файлов стилей и подключение их в HTML будет отвечать «Вебпак». 
Чтобы рассказать ему о CSS, импортируйте главный css-файл в index.js:
```js
// index.js
import './styles/index.css'; // добавьте импорт главного файла стилей
```

**Минификация CSS и добавление префиксов**
Уменьшение размера файла с сохранением его функциональности. При минификации из файла убираются комментарии, пробелы и переносы строк. Размер файла становится меньше и он быстрее загрузится в браузер пользователя.

Пора сделать css-код лёгким, и чтобы он везде поддерживался. В этом поможет минификация кода и автоматическая расстановка префиксов.
Для этого [установим PostCSS](https://postcss.org/) — инструмент для трансформации CSS.


---**Установите PostCSS и два плагина:**---
```Bash
npm i postcss-loader --save-dev
npm i autoprefixer --save-dev
npm i cssnano --save-dev
```
Первый пакет *postcss-loader* нужен, чтобы подключить PostCSS к «Вебпаку». 
Плагин *autoprefixer* научит PostCSS добавлять вендорные префиксы, 
а *cssnano* займётся минификацией css-кода.


---**Настройка PostCSS**---
Создайте в корне проекта файл postcss.config.js. Это файл для настроек PostCSS. В нём создайте объект module.exports со свойством plugins и подключите autoprefixer с cssnano:
```js
// postcss.config.js

// подключите плагины в файл
const autoprefixer = require('autoprefixer');
const cssnano = require('cssnano');

module.exports = {
  // подключите плагины к PostCSS
  plugins: [
    // подключите autoprefixer
    autoprefixer,
    // cssnano при подключении нужно передать объект опций
    // { preset: default } говорит о том, что нужно использовать
    // стандартные настройки минификации
    cssnano({ preset: 'default' })
  ]
};
```
*Настройка webpack*
Откройте файл webpack.config.js. В правило для обработки css-файлов подключите плагин PostCSS. Для этого в массив module.exports.module.rules.loader добавьте ещё один элемент — строку 'postcss-loader':
```js
{
  // применять это правило только к CSS-файлам
  test: /\.css$/,
  // при обработке этих файлов нужно использовать
  // MiniCssExtractPlugin.loader и css-loader
  use: [MiniCssExtractPlugin.loader, {
    loader: 'css-loader',
  },
    // Добавьте postcss-loader
  'postcss-loader']
},
```
Если вы используете директиву @import в css-файлах, после подключения postcss-loader, нужно изменить то, как подключается css-loader.
В конце css-loader необходимо передать опцию importLoaders со значением 1:
```js
{
  // применять это правило только к CSS-файлам
  test: /\.css$/,
  // при обработке этих файлов нужно использовать
  // MiniCssExtractPlugin.loader и css-loader
  use: [MiniCssExtractPlugin.loader, {
    loader: 'css-loader',
    // добавьте объект options
    options: { importLoaders: 1 }
  },
    // Добавьте postcss-loader
  'postcss-loader']
},
```
Эта опция [описана в документации сss-loader](https://webpack.js.org/loaders/css-loader/#importloaders). 
Значение 1 говорит о том, что некоторые трансформации PostCSS нужно применить до css-loader.

у Webpack очень широкие возможности. Полный их перечень и описание 
[содержится в документации](https://webpack.js.org/guides/getting-started/). 
Читать полностью не нужно. Заходите в неё, когда возникает потребность.