# Проект: Mesto.

## Учебный сайт
Сделан сайт в Яндекс Практикум, __Альбертом Тайгибовым__.
## По теме обучения: Адаптивная вестка
По этому проекту, мною были изучены навыки Адаптивной вестке, с использованием таких инструментов как:
* медиазапросы
* относительные величины
## Использованы технологии: HTML, CSS.
## Ссылка на сайт проекта: [https://albert-ti.github.io/mesto-project/index.html]

## JAVA SCRIPT

### -------------------------------------- НАВИГАЦИЯ ПО DOCUMENT:

**querySelector** - селектор запросов
**querySelectorAll** - общий селектор запросов
```js
// Поиск по селектору класса:
document.querySelectorAll('.class');
// Поиск по селектору тега:
document.querySelectorAll('.div');
// Поиск по смешанному селектору тега и класса:
document.querySelectorAll('div.class');
// Поиск по тегу первого уровня вложенности:
document.querySelectorAll('.class>div');
// Поиск по нескольким классам:
document.querySelectorAll('.class, .class__title');
// Поиск по вложенным классам:
document.querySelectorAll('.class .class__title');
// Поиск по ID:
document.querySelectorAll('#id');
// Поиск по атрибуту:
document.querySelectorAll('[type]');
// Поиск по атрибуту и значению:
document.querySelectorAll('[type="button"]');
```

### -------------------------------------- ПРОВЕРКА/ПОИСК УЗЛОВ:

**childNodes** - дочерние узлы
**firstChild** - первый дочерний узел
**lastChild** - последний дочерний узел

**hasChildNodes** - проверка(true/false) имеются ли у обьекта узлы

**previousSibling** - предыдущий узел обьекта
**nextSibling** - следующий узел обьекта
**parentNode** - к родительскому узлу


## -------------------------------------- ПРОВЕРКА/ПОИСК ЭЛЕМЕНТОВ:

**parentElement** - родительский элемент
**children** - дочерние элементы родителя
**previousElementSibling** - предыдущий элемент обьекта
**nextElementSibling** - следующий элемент обьекта
**firstElementChild** - первый дочерний элемент проверочного родителя
**lastElementChild** - последний дочерний элемент проверочного родителя
<!-- Все эти свойства доступны только для чтения. Перезаписать их не получится -->


**getElementsByTagName** - индивид. поиск по "тегу"
**getElementsByClassName** - индивид. поиск по "class"
**getElementsByName** - индивид. поиск по "name"
<!-- getElementById явл. Исклчючением -->
**getElementById** - индивид. поиск по "id"


### -------------------------------------- ПОИСК В СТРОКЕ:

**indexOf** - ищет символ в строке и возвращает его индекс 
```js 
'эспрессо'.indexOf('c'); // 1
// indexOf чувствителен к регистру:
'Шалаш'.indexOf('Ш'); // 0
'Шалаш'.indexOf('ш'); // 4 
```
**includes** - проверить, есть ли в строке набор символов(true/false)
```js
'хлеб да соль'.includes('соль'); // true
```
**startsWith** - поиск в начале строки(true/false)
**endsWith** - поиск в конце строки(true/false)
```js
const theRealEnd = 'Это ещё не конец';
theRealEnd.endsWith('конец'); // true 
```


### -------------------------------------- ПРЕОБРАЗОВАНИЕ СТРОК:

```js
'Включите Caps Lock'.toLowerCase(); // "включите caps lock"
'Выключите Caps Lock'.toUpperCase(); // "ВЫКЛЮЧИТЕ CAPS LOCK" 
```
Метод **split** - превращение строки в массив
```js
'Пришёл. Увидел. Победил.'.split(' '); // ["Пришёл.", "Увидел.", "Победил."]
'Пришёл. Увидел. Победил.'.split('. '); // ["Пришёл", "Увидел", "Победил."] 

// Отсортируйте этот массив по фамилиям гроссмейстеров в алфавитном порядке.
const chessChampions = ['Вильгельм Стейниц', 'Эммануил Ласкер', 'Хосе-Рауль Капабланка',]
	chessChampions.sort(function (a, b) {
	a = a.split(' ')[1].toLowerCase();
	b = b.split(' ')[1].toLowerCase();
	if (a < b) return -1;
	if (b < a) return 1;
	return 0;
});
console.log(chessChampions);

```
Метод **slice** - Извлечение части строки
```js
'Не прислоняться'.slice(6, 10); // "слон" 
```

### -------------------------------------- ИЗМЕНЕНИЯ В DOCUMENT:
### -------------------------------------- ВСТАВКА И ПЕРЕНОС ЭЛЕМЕНТОВ

<!-- минус этого способа грамозкость кода -->
**createElement** - Создание нового элемента
**createTextNode** - создание нового тесктового узла
**textContent** - "безопасный способ" изменения текста

**innerHTML** - получить/изменить внутренний контент HTML-тега (`XSS-уязвимости.`)
**outherHTML** - получить/изменить внутренний контент HTML-тега и сам обьект(тег)
<!-- методы добавления: -->
*befor* - пееред обьектом
*after* - после обьекта
*prepend* - внутрь начала обьекта
*append* - внутрь конец обьекта
*replaceWith* - заменяет node заданными узлами или строками
```js
// ПРИМЕР ДОБАВЛЕНИЯ ЭЛЕМЕНТОВ НА СТРАНИЦУ:
const list = document.querySelector('.todo-list');
const listItem1 = document.createElement('li');
const listItem2 = document.createElement('li');
const listItem3 = document.createElement('li');
list.append(listItem1, listItem2, listItem3);

// ПРИМЕР ПЕРЕМЕЩЕНИЯ ЭЛЕМЕНТОВ:
const list = document.querySelector('.todo-list');
// в свойстве children хранится
// псевдомассив дочерних элементов
const listItems = list.children;
// переместили первый элемент todo-листа в конец
list.append(listItems[0]); 
```


**insertAdjacentHTML** - Вставляем текст, элемент, HTML (`XSS-уязвимости.`)
**insertAdjacentText** - текст
**insertAdjacentElement** - элемент
<!-- ПАРАМЕТРЫ insertAdjacentHTML: -->
*beforebegin* - вставить HTML непосредственно перед обьектом
*afterbegin* - вставить HTML в начало обьекта
*beforeend* - вставить HTML в конец обьекта
*afterend* - вставить HTML непосредственно после обьекта

<!-- есть способ создания элементов без их минусов -->
(*insertAdjacentHTML* *innerHTML*) и (*createElement*)
это *тег template*:
```html
<!--Тег template — заготовка вёрстки. Её используют для создания элементов. 
Если добавить template в HTML, содержимое тега не отобразится на сайте: -->
<template id="user">
  <div class="user">
    <img class="user__avatar" alt="avatar">
    <p class="user__name"></p>
  </div>
</template>
```
```js
// В JavaScript мы можем получить этот элемент методом querySelector:
const userTemplate = document.querySelector('#user');
// Чтобы получить содержимое template, нужно обратиться к его свойству content:
const userTemplate = document.querySelector('#user').content; 
```


### -------------------------------------- КЛОНИРОВАНИЕ/УДАЛЕНИЕ УЗЛОВ

**cloneNode(false)** - Клонирование без дочерних элементов
**cloneNode(true)** - Глубокое клонирование вместе с содержимым
<!-- Важно: обработчики событий элемента не скопируются. Их придётся добавить заново. -->

**remove()** - ~~удаление~~ узлов
**closest** - Он возвращает ближайший родительский элемент с переданным селектором.
```js
// выберем кнопку удаления
const deleteButton = document.querySelector('.todo__item-button');
// добавим обработчик
deleteButton.addEventListener('click', function () {
  const listItem = deleteButton.closest('.todo__item');
  listItem.remove();
}); 
```


### -------------------------------------- УПРАВЛЕНИЕ КЛАССАМИ

**className** - получить/перезаписать класс
**classList** - Специальное свойство с методами для добавления/~~удаления~~ классов
```js
// добавить класс:
element.classList.add('active');
// Удалить класс:
element.classList.remove('active');
// Добавать класс если его нет, а еcли есть удалить.
element.classList.toggle('active');
// Проверка наличие класса, возвращает true/fasle
element.classList.contains('active');

// Рассмотрим пример:
if (element.classList.contains('active')) {
	console.log('У элемента есть класс active!')
}
```
<!-- Методы className classList: -->
*add* - добавить класс
*remove* - ~~Удалить~~ класс
*toggle* - Добавить класс если его нет, а елси есть ~~удалить~~
*contains* - Проверка наличие класса, возвращает true/fasle



### -------------------------------------- УПРАВЛЕНИЕ СТИЛЯМИ

*object.style.свойство = "значение";* - мы можем добавить стиль CSS-селектору
```js
element.style.marginBottom = "30px";
```
*object.style.cssText = свойство: значение;* - Полная перезапись стилей
```js
element.style.cssText = `
	margin-bottom: 30px;
	color: red;
`;
```


### -------------------------------------- АТРИБУТЫ И СВОЙСТВА

*переменная.href* - при вызове в консоли получаем содержимое ссылки(<input>)
*переменная.value* - при вызове в консоли получаем содержимое инпута(<a>)
*consol.dir(обьект)* - получить весь список свойств

**hasAttribute** *('attribute', значение)* - Проверяем наличие атрибута
**getAttribute** *('attribute', значение)* - Проверяем значение атрибута
**setAttribute** *('attribute', значение)* - Устанавливаем значение атрибута
**removeAttribute** *('attribute', значение)* - ~~Удаляем~~ атрибут

**dataset** - Нестандартный атрибут
```js
newElement.dataset.size = '1058';
console.log(newElement.dataset.size); // <div data-size = "1058"></div>
// зарезервированы для использования праграммистами.
```

### -------------------------------------- ОБРАБОТЧИК СОБЫТИЕ

*element.onclick*
```html
<!-- Использования атрибута в HTML: -->
<button onclick="console.log('click')" type="button" class="btn">Кнопка</button>
```
```js
// Исользование DOM-обьекта:
button.onclick = function () {
	console.log('click');
}
// Или выносим в отдельную функцию:
function showConsole() {
	console.log('click');
}
button.onclick = showConsole;
// Важно писать название функции без круглых скобок
// если мы напишем (), то тем самым вызовем автоматическое выполнение функции.
```

**.addEventListener** - добавить событие
**.removeEventListener**
*evt.preventDefault();* - метод позволяет остановить перезагрузку формы
```js
// Пример:
// СИНТАКСИС: element.addEventListener(event, handler[, option)
function showConsole() {
	console.log('click');
	console.log('clack');

	// чтобы не перенагружать браузер колличеством выполненего кода
	// удаляем после каждого нажатия.
	button.removeEventListener('click', showConsole);
}
button.addEventListener('click', showConsole);

// Опции Обработчика событий:
const option = {
	'capture': false, //фаза на кот. должен сработать обработчик
	'once': false, // если true, обработчик будет автоматич. удален
	'passive': false // если true, обработчик указывает, что не вызовет preventDefaulte()
}
```

### -------------------------------------- ЦИКЛЫ:

**WHILE FOR**
```js
// Циклы WHILE: Синтаксис
while (Условие) {
	Тело цикла
	Тут будет выполняться код
}

// Цикл FOR: Синтаксис
for (начало; Условие; Шаг) {
	Тело цикла
	Тут выполняется код
}
```
<!-- ДИРЕКТИВЫ break и continue Примеры:-->
**break** - Директива break останавливает цикл:
```js
for (let i = 2019; i < 2119; i++) {
    if (i % 4 === 0 && i % 100 !== 0) { // високосный год кратен 4, но не кратен 100
        console.log('Ближайший високосный год: ' + i);
        break;
    }
} // 'Ближайший високосный год: 2020' 
```
**continue** - пропускает текущую итерацию.
```js
for (let i = 2090; i < 2110; i++) {
  if (i % 4 === 0) {
    if (i % 100 === 0) continue; // пропуск года, кратного 100
    console.log('Високосный год: ' + i);
  }
}
// Високосный год: 2092
// Високосный год: 2096
// Високосный год: 2104
// Високосный год: 2108
/* Скрипт вывел все високосные годы от 2090 до 2110, но пропустил год 2100 */ 
```


### -------------------------------------- УСЛОВИЯ:

**КОНСТРУКЦИЯ switch-case**
```js
// Синтаксис:
switch (/* Переменная для проверки */) {
    case /* Первое возможное значение:
        Выполняемый код */
        break;
    case /* Второе возможное значение:
        Выполняемый код */
        break;
    ...
    case /* n-ое возможное значение:
        Выполняемый код */
        break
} 
```
**ТЕРНАРНЫЙ ОПЕРАТОР('?')**
<!-- Пример: -->
```js
const a = 5;
const b = a > 10 ? 5 : 0;
console.log(b); // 0, потому что a > 10 — false 

const love = true;
const result = love ? 'к сердцу прижмёт' : 'к чёрту пошлёт';

console.log(result); // "к сердцу прижмёт" 
```


### -------------------------------------- ФУНКЦИЯ:


Есть встроенные функции, например, **console.log** или **alert**
А есть функции, которые создаём мы самиФ
Если **function** передают как аргумент, её называют *«колбэком»*.

**ОБЬЯВЛЕНИЕ ФУНКЦИИ( Function Declaration )**

```js 
// объявляем функцию sayHello
function sayHello() {
	// тело функции
  console.log('Привет');
}
// вызываем её
sayHello(); // "Привет" 
```

Зачем нужны **function**
Основных причин — две.
	1.повторное использование кода.
	2.более понятный код.
```js
// вариант I
popupButton.addEventListener('click', function () {
  popup.classList.add('popup_is-opened');
});
// вариант II 
// используя аргумент при вызове можно такой код использовать повторно:
function openPopup(popupElement) {
  popupElement.classList.add('popup_is-opened');
}
popupButton.addEventListener('click', function () {
  openPopup(popup);
});
```

Переменную называют *глобальной*, если она объявлена в глобальной области видимости,
и *локальной* — если внутри функции:
```js
/* script.js */
// здесь глобальная область видимости
const a = 1; // это глобальная переменная
function callMe() {
  // а здесь область видимости функции callMe
  let b = 2; // это локальная переменная функции callMe
}
```

**Затенение** идентификаторов
если и снаружи, и внутри есть одинаковые идентификаторы, 
движок остановится на *внутреннем*, а *внешний* — проигнорирует.
```js
const dog = 'https://pictures.s3.yandex.net/frontend-developer/functions/dog-1.jpg';
function setDog() {
	// Внутри функции setDog затените глобальную константу dog
  const dog = 'https://pictures.s3.yandex.net/frontend-developer/functions/dog-2.jpg';
  document.querySelector('.dog').style.backgroundImage = `url(${dog})`;
}
document.querySelector('button').addEventListener('click', setDog);
```

**ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ( Function Expression.)**

```js
// В переменную можно записать и функцию — так же, как число или строку:
// запишем функцию в переменную multiply
const multiply = function (a, b) {
  return a * b;
};
// её можно вызвать по имени
multiply(2, 3); // 6 
```

Передача функции как *аргумент* — это тоже *функциональное выражение*.
*функциональное выражение* может быть анонимным. Это распространённый приём создания *колбэков*:
*Объявленную функцию* можно вызвать до объявления, *функциональное выражение* — нельзя.
```js
element.addEventListener('click', function () {
 console.log('Клик');
});
const arr = [1, 2, 3];
// эта функция тоже анонимна
arr.map(function (item) {
  return item * 2;
}); 
```

*function* которая возвращает другую *function*
```JS
function createFunction() {
  function simpleFunction() {
    console.log('Меня вернули, а затем вызвали!');
  }
  /* мы не вызываем функцию, а возвращаем её */
  return simpleFunction;
}
// в newFunction запишется ссылка на simpleFunction
const newFunction = createFunction();
newFunction(); // "Меня вернули, а затем вызвали!"
```

**СТРЕЛОЧНЫЕ ФУНКЦИИ**

1. Стрелочными могут быть только *функциональные выражения*.
```js
// функциональное выражение
const consoleCat = function (cat) {
  console.log(cat);
};
// стрелочная функция
const consoleWombat = (wombat) => {
  console.log(wombat);
};
```

2. Если директива *return* — единственное действие в теле стрелочной функции, 
можно опустить и директиву *return*, и фигурные скобки:
```js
const shorterSingleAnecdote = (anecdote) => `я знаю только один анекдот: ${anecdote}`;
```

3. Если возвращаемое значение — *объект*, его нужно заключить в круглые скобки.
   Иначе то, что в фигурных скобках, движок воспримет как *тело функции*: 
```js
const colorHex = () => ({ white: '#FFF' });
```

4. Если у *стрелочной функции* один параметр, можно не заключать его в скобки:
```js
// если параметр один, скобки необязательны 
const boatArrival = survivor => {
  console.log(`до другого берега доберётся только ${survivor}`);
};
boatArrival('козёл');
```

5. Стрелочные функции часто передают как *коллбэки*:
```js
const array = [1, 2, 3, 4];
array.forEach(() => {
  console.log('Кнопка нажата!');
}); 
```

6. Это особенно удобно, когда единственное, что делает *коллбэк*, 
	— возвращает значение. Можно использовать короткий *return*:
```js
const array = [1, 2, 3, 4];
const newArray = array.map(elem => elem * 2); 
```

**АРГУМЕНТЫ ПО УМОЛЧАНИЮ**

1. При объявлении функции описывают её *параметры*. При вызове — передают *аргументы*
```JS
const generateName = (firstName, lastName, middleName) => {
  if (middleName === undefined) {
    middleName = '';
  }
  return `${firstName} ${middleName} ${lastName}`;
};
generateName('Маша', 'Петрова'); // "Маша  Петрова"
```

2. В *ES6* появилась возможность задать значение *аргумента* по умолчанию:
```JS
function generateName(firstName, lastName, middleName = '') {
    return `${firstName} ${middleName} ${lastName}`;
}
generateName('Маша', 'Петрова'); // Маша  Петрова
generateName('Мария', 'Петрова', 'Ивановна'); // Мария Ивановна Петрова
```

3. Параметр по умолчанию может принимать любое значение: *число*, *строку*, *объект*, *функцию*. 
Это значение будет присвоено параметру, если аргумент не передан или равен undefined.
```JS
function generateName(firstName, lastName, middleName = '<без отчества>') {
    return `${firstName} ${middleName} ${lastName}`;
}
generateName('Маша', 'Петрова'); // Маша <без отчества> Петрова
generateName('Маша', 'Петрова', undefined); // Маша <без отчества> Петрова
generateName('Маша', 'Петрова', null); // Маша null Петрова
generateName('Маша', 'Петрова', ''); // Маша  Петрова
generateName('Мария', 'Петрова', 'Ивановна'); // Мария Ивановна Петрова
```

4. Значением одного *параметра* функции даже может быть другой её *параметр*:

```JS
// Whac-A-Mole — английское название игры «Убей крота»
const whacAMole = (startScore = 0, endScore = startScore) => {
    for (let i = 0; i <= 10; i += 1) {
        endScore = Math.random() > 0.5 ? endScore + 1 : endScore;
    }
    return endScore;
}
```


* В уроке о функциональных выражениях мы упомянули, что функцию, 
* созданную через объявление функции, можно вызвать до объявления:
```js
double(2); // 4

function double() {
	return num * 2;
}
```
* возможно потому что движок выполняет код не построчно сверху вниз,
* а он сначало *компилирует*, а лишь затем *интерпеитирует*.
* Компиляция проходит довольно сложно. Для нас важно, что в этом процессе
* происходит 2 вещи:
* 	1. Сначало дживок найдет все обьявленные функции и обьявит их.
* 	2. Затем найдет все переменные обьявленные через var, обьявит их
* 		и просвоит каждой значение undefind.
* Обьявление функций и переменных var произойдет в первую очередь.
* Это называется *"ПОДНЯТИЕ"*
```js
console.log(a); // undefined — объявление а поднялось, поэтому ошибки нетvar a = 2;
console.log(a); // 2
```
Переменные обьявленные через const и let, а также функции обьявленные через
функциональные выражения, не *"ПОДНИМАЮТСЯ"*.


### --------------------------------------  ОПЕРАТОРЫ:

В ES6 появился новый оператор:*...* называют либо *spread*, либо *rest*
Оператором *spread* можно «разложить» массив в отдельные аргументы функции
Второе назначение оператора *rest* собирают отдельные параметры функции в массив:
```js
// ПРИМЕР:
function consoleDogs(firstDog, ...otherDogs) {
  console.log(`Первый: ${firstDog}`);
  console.log(`Остальные: ${otherDogs}`);
}
consoleDogs('Спаниель', 'Овчарка', 'Борзая', 'Метис');

/* В консоль будет выведено:
  Первый: Спаниель
  Остальные: ['Овчарка', 'Борзая', 'Метис']
*/
```

**ПОБИТОВЫЕ ОПЕРАТОРЫ:**

AND(и)*( & )*
OR(или)*( | )*
XOR(Побитовое исключение или)
NOT(не)*(~ )*
LEFT SHIFT(левый сдвиг)*( << )*
RIGHT SHIFT(правый сдвиг)*( >> )*
ZERO_FILL RIGHT SHIFT(правый сдвиг с заполнение нуля)*( >>> )*


**ОПЕРАТОРЫ СРАВНЕНИЯ:**

Больше: *a > b*
Меньше: *a < b*
Больше или равно: *a >= b*
меньше или равно: *a <= b*
Равно: *a == b*
Не равно: *a != b*
Строго равно: *a === b*
Строго не равно: *a !== b*


**ЛОГИЧЕСКИЕ ОПЕРАТОРЫ:**

*(||)* - оператор "или"
*(!)* - оператор "не"
*(&&)* - оператор "И"

Boolean *('Непустая строка');* // true
Boolean *('');* // false
Boolean *(1);* // true
Boolean *(0);* // false
Boolean *(NaN);* // false
Boolean *(null);* //false
Boolean *(undefined);* // false
Boolean *({});* // true
Boolean *([]);* //true 


### -------------------------------------- ОБЬЕКТ Math. И ЕГО МЕТОДЫ:

*Math.floor(9.99);*  9 округляет переданное число «вниз»
*Math.ceil(9.01);*  10 округляет «вверх»
*Math.round(9.51);*  10 округляет до ближайшего целого
*Math.max(1, 2, 3, 4, 5);*  5 возвращает наибольшее из переданных чисел
*Math.min(1, 2, 3, 4, 5);*  1 возвращает наименьшее из переданных чисел
*Math.random();*  0.31764219954126016 возвращает случайное число от 0 включительно до 1 не включительно

**parseInt** функция приводит переданный аргумент к целому числу
```js
parseInt('38 попугаев'); // 38 
parseInt('100', 10); // 100 (100 в 10чной системе исчисления)
parseInt('100', 2); // 4 (100 в 2чной системе)
```
**parseFloat** возвращает число с плавающей точкой(дробное)


### -------------------------------------- МАССИВЫ:
```js ШПАРГАЛКА ПО МЕТОДАМ МАССИВОВ
1	concat()	Объединяет массивы и элементы
2	push()	Добавляет элементы в конец массива
3	pop()	Удаляет последний элемент массива и возвращает его значение
4	unshift()	Добавляет элементы в начало массива
5	shift()	Удаляет первый элемент массива и возвращает его значение
6	slice()	Копирует часть массива и создаёт из неё новый массив
7	splice()	Удаляет часть элементов, а на их место ставит новые
8	forEach()	Перебирает элементы, выполняя для каждого какой-то код
9	map()	Создаёт новый массив, получая каждый элемент из уже имеющегося массива
10	filter()	Создаёт новый массив, выкидывая из исходного элементы по заданным правилам
11	some()	Проверяет, есть ли в массиве хоть один элемент, соответствующий заданному правилу
12	every()	Проверяет, все ли элементы массива соответствуют заданному правилу
13	find()	Проверяет, есть ли в массиве определённый элемент
14	reduce()	Сводит массив к какому-то одному значению
15	sort()	Сортирует массив
```
1. метод **cancat** - применяется к массиву и создаёт из него новый
```js
// ПРИМЕР:
const toDoList = ['Посадить дерево', 'Построить дом'];
const toDoListUpdated = toDoList.concat('Вырастить сына');
console.log(toDoListUpdated); // ["Посадить дерево", "Построить дом", "Вырастить сына"]
/*
*Метод concat не меняет структуру начального массива, а возвращает новый. Изменения в новом массиве *не приведут к изменению исходного. Это делает код более предсказуемым.
*/
```

2. Метод **join** - создаёт строку из элементов массива, разделённых запятой
```js
// ПРИМЕР:
const bremenMusicians = ['Кот', 'Пёс', 'Трубадур', 'Осёл', 'Петух'];
console.log(`Представляем музыкантов: ${bremenMusicians.join(', ')}`);
// "Представляем музыкантов: Кот, Пёс, Трубадур, Осёл, Петух"
// при этом с исходным массивом ничего не произошло:
console.log(bremenMusicians);
// ["Кот", "Пёс", "Трубадур", "Осёл", "Петух"] 
```

3. метод **push** - добавляет переданные ему аргументы в конец массива
```js
// ПРИМЕР:
const emeraldCityHeroes = ['Лев', 'Дровосек', 'Страшила'];
emeraldCityHeroes.push('Элли', 'Тотошка');
console.log(emeraldCityHeroes);
// ["Лев", "Дровосек", "Страшила", "Элли", "Тотошка"] 
```

4. метод **pop** - удаляет последний элемент массива
```js
// ПРИМЕР:
const insects = ['Бабочка', 'Мотылёк', 'Божья коровка', 'Комар'];
console.log(insects.pop()); // "Комар"
console.log(insects); // ["Бабочка", "Мотылёк", "Божья коровка"] 
```

5. метод **shift** - удаляет первый элемент массива
```js
// ПРИМЕР:
const italyCities = ['Помпеи', 'Рим', 'Неаполь'];
const volcanoEruption = italyCities.shift();

// метод shift() возвращает удалённый элемент
console.log(volcanoEruption); // "Помпеи"
// массив остался без первого элемента
console.log(italyCities); // ["Рим", "Неаполь"] 
```

6. Метод **unshift** - добавляет элементы в начало массива
```js
const queue = ['Рабочие', 'Школьники', 'Студенты'];
queue.unshift('Пенсионеры', 'Инвалиды');
console.log(queue); // ["Пенсионеры", "Инвалиды", "Рабочие", "Школьники", "Студенты"]
```

7. Метод **slice(index, index)** копирует часть массива и делает из неё новый массив
```js
// индекс элемента, с которого нужно начать копирование (включительно);
// индекс элемента, на котором нужно остановиться (не включительно).
// ПРИМЕР:
const months = [
  'Январь',
  'Февраль',
  'Март',
  'Апрель',
  'Май',
  'Июнь',
  'Июль',
  'Август',
  'Сентябрь',
  'Октябрь',
  'Ноябрь',
  'Декабрь'
];
// начиная с индекса 2 ("Март") и до, но не включая индекс 5 ("Июнь")
const spring = months.slice(2, 5);
console.log(spring); // ["Март", "Апрель", "Май"]
console.log(months); /* ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"] */
// Как видите, исходный массив остался нетронутым
```

8. Метод **splice(index, index, аргументы)** удаляет элементы из массива 
и добавляет на их место новые

Первый аргумент метода — индекс элемента, с которого надо начать удалять.
Второй — сколько элементов нужно удалить.
Аргументы с третьего — элементы, которые мы хотим поставить на место удалённых. Их может быть сколько угодно или не быть вообще:

```js
// ПРИМЕР:
const week = [
  'Понедельник',
  'Вторник',
  'Среда',
  'Четверг',
  'Пятница',
  'Суббота',
  'Воскресенье'
];
// начиная с индекса 0 удалим пять элементов и вставим на их место другие пять
const removedItems = week.splice(0, 5, 'Воскресенье', 'Суббота', 'Воскресенье', 'Суббота', 'Воскресенье');
console.log(removedItems); // ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница"]
console.log(week); // ["Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье", "Суббота", "Воскресенье"]

// Этот код изменит исходный массив и вернёт новый из удалённых элементов. 
// Новые значения добавлять необязательно — можно удалить существующие:
const planets = [
  'Меркурий',
  'Венера',
  'Земля',
  'Марс',
  'Юпитер',
  'Сатурн',
  'Уран',
  'Нептун'
];
planets.splice(2, 1); // ["Земля"]
console.log(planets); // ["Меркурий", "Венера", "Марс", "Юпитер", "Сатурн", "Уран", "Нептун"]
// И наоборот. Можно ничего не удалять — только добавить новые элементы:
planets.splice(2, 0, "Земля"); // []
console.log(planets); // ["Меркурий", "Венера", "Земля", "Марс", "Юпитер", "Сатурн", "Уран", "Нептун"]
```

**ПЕРЕБОР МАССИВА: МЕТОДЫ FOREACH И MAP**

метод **forEach** - перебор массива,
(Метод *forEach* — более удобная для работы с массивом версия цикла *for*)
Метод *forEach* нужен для обхода массива. 
В качестве аргумента *forEach* принимает функцию. 
Она будет вызвана на каждом элементе массива поочерёдно:
```js
// ПРИМЕР:
const how = ['быстрее', 'выше', 'сильнее'];
how.forEach(function (item) {
    console.log(item + '.');
});
/*
  быстрее.
  выше.
  сильнее.
*/ 
//версия цикла for:
const how = ['быстрее', 'выше', 'сильнее'];
for (let i = 0; i < how.length; i += 1) {
    console.log(how[i] + '.');
}// Этот цикл работает аналогично методу forEach выше 
```

<!-- Метод  forEach удобно использовать для работы 
с массивоподобными объектами. Например, с NodeList. 
Частая задача — пройтись по нескольким DOM элементам, 
вызвав для каждого из них функцию: -->
```js
const elements = document.querySelectorAll('.text');
elements.forEach((item) => {
   item.classList.add('text_is-active');
});
`Но с`forEach()`нельзя использовать директивы` continue и break
```

Метод **map** - Создание одного массива из другого,
1. В качестве аргумента *map*, как и *forEach*, принимает функцию
2. Метод *map* нельзя применить к массивоподобным объектам
3. Mетод *map* удобно использовать в тех случаях, когда нужно сохранить исходный 
массив:
```js
// ПРИМЕР:
const elements = document.querySelectorAll('.text');
const elementsArr = Array.from(elements);

const newArr = elementsArr.map((item) => {
    item.classList.add('text_is-active');
});
```

**ОТБОР ЭЛЕМЕНТОВ МАССИВА МЕТОД FILTER**

Метод **filter** отсеивает элементы массива по заданному признаку
Метод *filter* принимает колбэк в качестве аргумента
Он должен вернуть *true* или *false* в зависимости от того, 
хотим мы оставить текущий элемент массива или отфильтровать:
Метод *filter* создаёт новый массив из элементов, для которых 
функция-фильтр вернула *true*. 
При этом исходный массив не меняется.
```js
// ПРИМЕР:
const a = [1, 9, 2, 2, 3, 4, 1, 7, 8, 0, 9, 0, 1, 5, 3];
// отберём элементы которые больше 5
const b = a.filter(function (item) {
  return item > 5
});
console.log(b); // [9, 7, 8, 9]

// Метод filter создаёт новый массив из элементов, для 
// которых функция-фильтр вернула true. При этом исходный массив не меняется.
const movies = [
	'Титаник (1997)',
	'Чёрная Пантера (2018)',
	'Остров Собак (2018)',
	'Омерзительная Восьмерка (2015)'
];
const moviesFiltered = movies.filter(function (item) {
	return item.includes('2018');
});
```
**МЕТОДЫ SOME, EVERY, FIND**

Метод **some** проверяет, есть ли в массиве хотя бы один элемент (англ. "хотя бы один")
Колбэк с этим правилом проверяет каждый элемент и возвращает *true* или *false*
```js
// ПРИМЕР:
const oceanResidents = ['Флаундер', 'Немо', 'Губка Боб', 'Аквамен'];
const nemo = oceanResidents.some(function (resident) {
    return resident === 'Немо';
});
console.log(nemo); // true
```

 Метод **find** Поиск элемента в массиве (англ. "найти")
 Метод *find* очень похож на some. Единственное отличие:
 *some* возвращает *булево значение*, а 
 *find* — значение элемента, на котором он завершил проверку:
 ```JS
// ПРИМЕР:
 const birds = [
    'Ворона',
    'Чёрно-белая ворона',
    'Белая ворона',
    'Ворона обыкновенная'
];
const includesCrow = birds.some(function (bird) {
    return bird.includes('ворона');
});
const crow = birds.find(function (bird) {
    return bird.includes('ворона');
});
console.log(includesCrow); // true
console.log(crow); // "Чёрно-белая ворона"
// Метод find прекращает работу после того, как колбэк впервые
// найдет true. Используйте его там где не нужно обходить весь массив
// а просто нужно найти что то в нем.
```

Метод **every** Проверка элементов массива (англ. "каждый")
Метод *every* тоже похож на some, 
но проверяет все элементы массива и возвращает *true*, 
только если все элементы прошли проверку.
Колбэк — единственный аргумент метода. 
Он содержит логику проверки каждого элемента и возвращает *true* или *false*:
```js
const jokes = [
  'смешная шутка и доля правды',
  'не очень смешной анекдот + доля правды',
  'доля правды в дурацкой шутке, услышав которую, все улыбнулись из вежливости'
];
const allJokesWithTruth = jokes.every(function (joke) {
  return joke.indexOf('доля правды') > -1;
});
console.log(allJokesWithTruth); // true
// Если по мере перебора элементов колбэк возвращает false, 
// метод every завершает проверку и тоже возвращает false.
```

**REDUCE**

Метод **reduce** перебирает элементы массива и сводит его к одному значению.(англ. "сводить")
Он работает как *forEach*: перебирает элементы массива и выполняет для каждого свой код
У колбэка *reduce* те же аргументы, но добавляется один новый
Он ставится на первое место, а «старые» идут за ним: 
текущий элемент, индекс и исходный массив.
Есть массив чисел, нужно посчитать сумму всех его элементов.
```js
// ПРИМЕР:
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const sum = arr.reduce(function (previosValue, item) {
	console.log(`previosValue: ${previosValue}, item: ${item}`);
	return previosValue + item;
})
console.log(`sum: ${sum}`);
/*
 previousValue: 1, item: 2
 previousValue: 3, item: 3
 previousValue: 6, item: 4
 previousValue: 10, item: 5
 previousValue: 15, item: 6
 previousValue: 21, item: 7
 previousValue: 28, item: 8
 previousValue: 36, item: 9
 sum: 45
*/ 
```
когда результат работы *reduce* — число или строка
Когда на выходе нужен массив или объект
второй аргумент обязателен.
```js
const order = ['яблоко', 'банан', 'апельсин', 'банан', 'яблоко', 'банан'];
const result = order.reduce(function (prevVal, item) {
  if (!prevVal[item]) {
    // если ключа ещё нет в объекте, значит это первое повторение
    prevVal[item] = 1;
  } else {
    // иначе увеличим количество повторений на 1
    prevVal[item] += 1;
  }
  // и вернём изменённый объект
  return prevVal;
}, {}); // Начальное значение — пустой объект.
console.log(result); // { яблоко: 2, банан: 3, апельсин: 1 }

---Суть метода reduce---
Как работает метод reduce:
1.сводит массив к одному значению: числу, массиву, объекту;
2.принимает на вход 2 аргумента: обязательный колбэк и исходное значение его первого аргумента;
3.содержит в колбэке 4 аргумента: промежуточное значение, текущий элемент, 
его индекс и сам исходный массив.
```

Метод **sort** Он сортирует массив по возрастанию, убыванию и вообще как угодно.
Метод *sort* принимает на вход колбэк.
Но для других методов колбэк обязателен, а для *sort* нет:

```js
// Метод *sort* работал с элементами массива как со строками. 
// Будь это слова, они бы выстроились по алфавиту:

const fruits = ['яблоко', 'банан', 'апельсин', 'томат'];
fruits.sort(); // ["апельсин", "банан", "томат", "яблоко"] 

//  отсортируем числа его по возрастанию:

const myNumbers = [0, 3.14, 2.718, 13];
myNumbers.sort(function (a, b) {
    return a - b;
  /* Если a меньше b, вернётся отрицательное число.
  Это значит, что a должно расположиться в итоговом массиве
  раньше, b — позже. Например:

    a = 0, b = 3.14
    a - b = -3.14
  Получили отрицательное число, значит a стоит раньше b */
});
console.log(myNumbers); // [0, 2.718, 3.14, 13] — так и есть
```


### -------------------------------------- ОБЬЕКТЫ:

ПРИМЕР:
В реальном мире есть разные объекты. Например, автомобиль ВАЗ-2101:
У этого объекта есть свойства: 
	1. модель, 
	2. год выпуска, 
	3. количество дверей, 
	4. наличие кондиционера.
У объектов в JavaScript тоже есть свойства: это пары *«ключ: значение»*

Обычно ключи объекта — строки. 
А значениями могут быть данные любых типов, в том числе и другие объекты.
```js
const car = {
	model: 'ВАЗ 2101',
	year: 1983,
	doors: 4,
	hasAirConditioner: false,
	owner {
		name: 'Albert',
		age: 33
	}
};
```

В объекте три ключа: one, two и three. 
Обратиться к их свойствам можно через точку:
```js
const obj = {
    one: 1,
    two: 2,
    three: 3
};
console.log(obj.one); // 1
console.log(obj.two); // 2
console.log(obj.three); // 3

// А что, если обратиться к несуществующему ключу four?
// Ошибки не будет. При обращении к свойству, которого в объекте нет, 
// вернётся undefined.
console.log(obj.four); // undefined 
```

**Запись свойств**
```js
// создадим объект с тремя свойствами
const obj = {
    one: 1,
    two: 2,
    three: 3
};

// запишем ещё одно
obj.four = 4;

console.log(obj.four); // 4
```

**Короткая запись свойств**
Записать в свойство объекта значение переменной 
или функцию — довольно частая задача
```js
const human = 'Дядя Фёдор';
const cat = 'Матроскин';
const dog = 'Шарик';

function getCartoonName() {
  return 'Трое из Простоквашино';
}

const cartoon = {
  human,
  cat,
  dog,
  getCartoonName
};
```